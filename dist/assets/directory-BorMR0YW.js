import{aA as x,f as g,h as z}from"./vendor-cKlqYlgl.js";import{T as y}from"./index-iXBYOgta.js";const D={async getDirectories(){return(await y.get("/api/v1/directories")).data||[]},async getDirectoriesPage(e={}){const{current:a=1,size:s=10}=e;return(await y.get("/api/v1/directories/page",{params:{current:a,size:s}})).data},async getDirectoryById(e){return(await y.get(`/api/v1/directories/${e}`)).data},async createDirectory(e){return(await y.post("/api/v1/directories",e)).data},async updateDirectory(e,a){return(await y.put(`/api/v1/directories/${e}`,a)).data},async deleteDirectory(e,a=!1){const s=a?{force:!0}:{};return await y.delete(`/api/v1/directories/${e}`,{params:s}),!0},async moveDirectory(e,a){return(await y.patch(`/api/v1/directories/${e}/move`,a)).data}},w={transformToTree(e){if(!Array.isArray(e)||e.length===0)return[];const a=new Map,s=[];return e.forEach(c=>{const d=this.transformDirectory(c);d.children=[],a.set(d.id,d)}),e.forEach(c=>{const d=a.get(c.id);if(c.parentId===0||c.parentId===null||c.parentId==="root")s.push(d);else{const u=a.get(c.parentId);u&&(u.children.push(d),u.folderCount=u.children.length)}}),s},transformDirectory(e){return{id:e.id,name:e.name,type:"folder",path:e.path,parentId:e.parentId===0?null:e.parentId,description:e.description||"",level:this.calculateLevel(e.path),size:0,fileCount:0,folderCount:0,createdAt:e.createdAt,updatedAt:e.updatedAt,createTime:e.createdAt,updateTime:e.updatedAt,hasChildren:e.hasChildren||!1,children:[]}},calculateLevel(e){return!e||e==="/"?0:(e.match(/\//g)||[]).length-1},transformToBackend(e){return{name:e.name,parentId:e.parentId===null?0:e.parentId,description:e.description||""}}},q=x("directory",()=>{const e=g([]),a=g(null),s=g(!1),c=g(null),d=g([]),u=g({current:1,size:10,total:0,pages:0}),E=z(()=>a.value&&a.value.path||"/"),P=z(()=>a.value&&a.value.name||"根目录"),b=async()=>{s.value=!0,c.value=null;try{const r=await D.getDirectories(),o=w.transformToTree(r);e.value=o,!a.value&&o.length>0&&(a.value=o[0])}catch(r){c.value=r.message||"获取目录树失败",console.error("获取目录树失败:",r)}finally{s.value=!1}},I=async(r=1,o=10)=>{s.value=!0,c.value=null;try{const t=await D.getDirectoriesPage({current:r,size:o});u.value={current:t.current,size:t.size,total:t.total,pages:t.pages},d.value=t.records.map(n=>w.transformDirectory(n))}catch(t){c.value=t.message||"获取目录列表失败",console.error("获取目录列表失败:",t)}finally{s.value=!1}},j=async r=>{r!==u.value.current&&await I(r,u.value.size)},O=async r=>{r!==u.value.size&&await I(1,r)},$=r=>{a.value=r},m=(r,o=e.value)=>{for(const t of o){if(t.id===r)return t;if(t.children&&t.children.length>0){const n=m(r,t.children);if(n)return n}}return null};return{directoryTree:e,currentDirectory:a,loading:s,error:c,pageDirectories:d,pagination:u,currentDirectoryPath:E,currentDirectoryName:P,fetchDirectoryTree:b,fetchDirectoriesPage:I,changePage:j,changePageSize:O,setCurrentDirectory:$,findDirectoryById:m,createDirectory:async r=>{s.value=!0,c.value=null;try{const o={name:r.name,parentId:r.parentId,description:r.description||""},t=await D.createDirectory(o),n=w.transformDirectory(t);n.children=[];const i=m(o.parentId);return i?(i.children||(i.children=[]),i.children.push(n),i.folderCount=i.children.length,i.hasChildren=!0):o.parentId===1&&e.value.push(n),await I(u.value.current,u.value.size),n}catch(o){throw c.value=o.message||"创建目录失败",console.error("创建目录失败:",o),o}finally{s.value=!1}},updateDirectory:async(r,o)=>{s.value=!0,c.value=null;try{const t=await D.updateDirectory(r,o),n=w.transformDirectory(t),i=m(r);i&&(n.children=i.children,Object.assign(i,n));const f=d.value.find(v=>v.id===r);return f&&Object.assign(f,n),n}catch(t){throw c.value=t.message||"更新目录失败",console.error("更新目录失败:",t),t}finally{s.value=!1}},deleteDirectory:async(r,o=!1)=>{var t;s.value=!0,c.value=null;try{await D.deleteDirectory(r,o);const n=(f,v)=>{for(let p=0;p<f.length;p++){if(f[p].id===v)return f.splice(p,1),!0;if(f[p].children&&n(f[p].children,v))return f[p].folderCount=f[p].children.length,!0}return!1};n(e.value,r);const i=d.value.findIndex(f=>f.id===r);return i!==-1&&(d.value.splice(i,1),u.value.total>0&&(u.value.total-=1)),((t=a.value)==null?void 0:t.id)===r&&e.value.length>0&&(a.value=e.value[0]),!0}catch(n){throw c.value=n.message||"删除目录失败",console.error("删除目录失败:",n),n}finally{s.value=!1}},moveDirectory:async(r,o)=>{s.value=!0,c.value=null;try{const t=await D.moveDirectory(r,{newParentId:o}),n=w.transformDirectory(t),i=m(r);if(!i)throw new Error("要移动的目录不存在");const f={...i},v=(l,A)=>{for(let h=0;h<l.length;h++){if(l[h].id===A)return l.splice(h,1)[0];if(l[h].children&&l[h].children.length>0){const C=v(l[h].children,A);if(C)return l[h].folderCount=l[h].children.length,C}}return null},p=v(e.value,r);if(!p)throw new Error("从目录树中移除目录失败");if(Object.assign(p,n),o===null||o===0)e.value.push(p);else{const l=m(o);if(!l)throw new Error("目标父目录不存在");l.children||(l.children=[]),l.children.push(p),l.folderCount=l.children.length,l.hasChildren=!0}const T=d.value.find(l=>l.id===r);return T&&Object.assign(T,n),n}catch(t){throw c.value=t.message||"移动目录失败",console.error("移动目录失败:",t),t}finally{s.value=!1}},clearError:()=>{c.value=null}}});export{q as u};
